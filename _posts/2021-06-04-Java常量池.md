---
title: Java中的常量池
author: 糖果炒蛋
tags: JVM 常量池 
---

面试的时候经常会被问到常量池有关问题，自己学的也是一知半解，在此整理一下相关内容。

# 常量和常量值

首先明确一下什么是常量，常量值：

> **常量**是指在程序的整个运行过程中值保持不变的量。在这里要注意常量和常量值是不同的概念，**常量值**是常量的具体和直观的表现形式，常量是形式化的表现。通常在程序中既可以直接使用常量值，也可以使用常量。

## 常量值

常量值又称为字面常量，它是通过数据直接表示的，因此有很多种数据类型，像整型和字符串型等。

- 整型常量值

  Java整型常量主要有3种形式：

  - 十进制数（如54、-67、0）

  - 八进制数（以0开头表示）

  - 十六进制数（以0x或0X开头）

- 实型常量值

  Java 的实型常量值主要有2种形式：

  - 十进制数形式（如12.34、-98.0）
  - 科学计数法形式（如1.75e5或32&E3）

- 布尔型常量值

  Java 的布尔型常量只有两个值，即 false（假）和 true（真）

- 字符型和字符串常量值

  Java 的字符型常量值是用单引号引起来的一个字符（如 'e'、E'，包括转义字符）

  java用双引号用来表示字符串，像 "11"、"d" 等都是表示单个字符的字符串。

## 常量

常量不同于常量值，它可以在程序中用符号来代替常量值使用，因此在使用前必须先定义。常量与变量类似，也需要初始化，即在声明常量的同时要赋予一个初始值。常量一旦初始化就不可以被修改。

Java 语言使用 final 关键字来定义一个常量，其语法如下所示：

```java
final dataType variableName = value
```

其中，final 是定义常量的关键字，dataType 指明常量的数据类型，variableName 是变量的名称，value 是初始值。

final 关键字表示最终的，它可以修改很多元素，修饰变量就变成了常量。例如，以下语句使用 final 关键字声明常量。

```java
public class HelloWorld {
    // 静态常量
    public static final double PI = 3.14;
    // 声明成员常量
    final int y = 10;
    public static void main(String[] args) {
        // 声明局部常量
        final double x = 3.3;
    }
}
```

常量有三种类型：静态常量、成员常量和局部常量。

在定义常量时，需要注意如下内容：

- 在定义常量时就需要对该常量进行初始化。
- final 关键字不仅可以用来修饰基本数据类型的常量，还可以用来修饰对象的引用或者方法。
- 为了与变量区别，常量取名一般都用大写字符。

# 常量池

在 Java 的内存分配中，总共 3 种常量池：

## 全局字符串池（string pool也有叫做string literal pool）

### 字符串常量池在 Java 内存区域的哪个位置

- 在 JDK6.0 及之前版本，字符串常量池是放在 Perm Gen 区(也就是方法区)中，此时常量池中存储的是对象。
- 在 JDK7.0 版本，字符串常量池被移到了堆中了。此时常量池存储的就是引用了。在 JDK8.0 中，永久代（方法区）被元空间取代了。

### 字符串常量池(StringTable)

在HotSpot（下文皆为HotSpot）JVM中实现字符串常量池功能的是一个StringTable类，它是一个Hash表（本质上就是个 `HashSet<String>`），默认长度大小为1009（JDK7.0可以通过`-XX:StringTableSize=66666`指定大小）；它只存储对java.lang.String 实例的引用，而不存储 String 对象的内容。这个 StringTable 在每个 HotSpot VM 的实例里只有一份，被所有的类共享。

## class 文件常量池（class constant pool）

我们都知道，class 文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的`各种字面量(Literal)和符号引用(Symbolic References)`。

- **字面量**比较接近 Java 语言层面常量的概念，如文本字符串、被声明为 final 的常量值等`。
- **符号引用**则属于编译原理方面的概念，包括了如下三种类型的常量：
  - 类和接口的全限定名
  - 字段的名称和描述符
  - 方法的名称和描述符

常量池的每一项常量都是一个表，一共有如下表所示的11种各不相同的表结构数据，这每个表开始的第一位都是一个字节的标志位，代表当前这个常量属于哪种常量类型。

![img](https://cdn.jsdelivr.net/gh/GroundZeros/ImageHost@main/images/20210604143508.png)

## **运行时常量池（runtime constant pool）**

运行时常量池是方法区的一部分。

当 Java 文件被编译成 class 文件之后，也就是会生成上面所说的 class 常量池，那么运行时常量池又是什么时候产生的呢？

VM 在执行某个类的时候，必须经过`加载、连接、初始化`，而连接又包括`验证、准备、解析（resolve）`三个阶段。而当类加载到内存中后，JVM 就会将 class 文件常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面也说了，class 常量池中存的是`字面量和符号引用`，也就是说它们存的并不是对象的实例，而是对象的符号引用值。而经过`解析（resolve）` 之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是上面所说的 StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。

# 三种常量池之间的关联

关于 JVM 执行的时候，还涉及到了`字符串常量池`。

*在类加载阶段， JVM 会在堆中创建对应这些 class 文件常量池中的字符串对象实例，并在字符串常量池中驻留其引用。具体在 resolve 阶段执行。这些常量全局共享。*

这里说的比较笼统，没错，是 resolve 阶段，但是并不是大家想的那样，立即就创建对象并且在字符串常量池中驻留了引用。 **JVM 规范里明确指定 resolve 阶段可以是 lazy 的。**

JVM 规范里 Class 文件常量池项的类型，有两种东西：`CONSTANT_Utf8 和CONSTANT_String`。前者是 UTF-8 编码的字符串类型，后者是 String 常量的类型，但它并不直接持有 String 常量的内容，而是只持有一个 index，这个 index 所指定的另一个常量池项必须是一个 CONSTANT_Utf8 类型的常量，这里才真正持有字符串的内容。

在JVM中，运行时常量池里，CONSTANT_Utf8 会在类加载的过程中就全部创建出来，而CONSTANT_String则是在`lazy resolve` 的，例如说在第一次引用该项的 ldc 指令被第一次执行到的时候才会 resolve。那么在尚未 resolve 的时候，HotSpot VM 把它的类型叫做`JVM_CONSTANT_UnresolvedString`，内容跟 Class 文件里一样只是一个 index；等到 resolve 过后这个项的常量类型就会变成最终的 `JVM_CONSTANT_String`，而内容则变成实际的那个 oop。

看到这里想必也就明白了， 就 HotSpot VM 的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在 StringTable 中并没有相应的引用，在堆中也没有对应的对象产生）。所以上面提到的，经过 resolve 时，会去查询全局字符串池，最后把符号引用替换为直接引用。（即字面量和符号引用虽然在类加载的时候就存入到运行时常量池，但是对于 lazy resolve 的字面量，具体操作还是会在 resolve 之后进行的。）

# 总结

1. 全局字符串常量池在 JVM 中只有一份，存放的是字符串常量的引用值。

2. class 常量池是在编译的时候每个 class 都有的，在编译阶段，存放各种字面量和符号引用。

3. 运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个 class 都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。

4. class 文件常量池中的字符串字面量在类加载时进入到运行时常量池，在真正在解析（resolve）阶段（即执行 ldc 指令时）时将该字符串的引用存入到字符串常量池中，另外运行时常量池相对于 class 文件常量池具备动态性，有些常量不一定在编译期产生，也就是并非预置入 class 文件常量池的内容才能进入到方法区运行时常量池，运行期间通过 intern() 方法，将字符串常量存入到字符串常量池中和运行时常量池。

参考：<http://c.biancheng.net/view/763.html>

<https://zhuanlan.zhihu.com/p/107776367>

